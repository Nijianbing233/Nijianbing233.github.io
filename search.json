[{"title":"Hexo+Github+Netlify博客搭建教程 友情链接+踩坑注意事项","url":"/2025/01/18/2589351ee9dc/","content":"\n前言最近在编程导航上看到了这篇博客搭建指南。于是着手操作从零开始搭建了一个自己的 Hexo 博客。在过程中，大部分步骤比较顺利，但也踩了一些坑。为了帮助有同样需求的朋友少走弯路，我记录了自己的经验、工具选择以及注意事项，希望对你·有所帮助。\n\n1. 使用 NVM 管理 Node.js 版本在实际项目开发中，Node.js 是不可或缺的工具。为了便于管理多个版本的 Node.js，我推荐使用 **NVM (Node Version Manager)**。它可以快速安装和切换 Node.js 的版本，极大地方便了开发环境的配置。\n参考教程：NVM 安装与使用指南。\n\n2. Git Bash 网络代理问题使用 Git Bash 执行 Git 命令时，可能会遇到网络代理的问题，尤其是在访问 GitHub 时连接速度很慢甚至无法连接。\n解决方案：\n\n配置代理地址。\n参考这篇博客：Git Bash 网络代理配置。\n\n\n3. 个人域名购买与解析个人域名的购买非常简单：\n\n访问域名服务商网站（如阿里云）。\n\n搜索你喜欢的域名，挑选性价比高的直接购买。\n\n购买后，进入解析设置，添加两条解析记录即可完成域名绑定。\n记得一定要添加CNAME文件，每一次提交代码之后GitHub里面的CNAME文件都会被清除。想要持久化保存的话必须要在本地文件夹的source文件夹内添加CNAME文件，先就用记事本，然后把.txt后缀删掉就行，里面是你自己的网站比如wuhu233.site，CNAME不用后缀，把后缀去掉\n\n\n参考：阿里云域名购买指南\n\n4. Hexo 初始化时的命名问题运行 hexo init 时，一定要在命令后面跟上项目名称。例如：\nhexo init my-blog\n\n如果不指定名称，可能会导致初始化失败或报错。\n5. Hexo 主题配置Hexo 提供了丰富的主题供用户选择，主题配置是博客个性化的重要部分。以下是使用主题的步骤：\n\n查找主题访问 Hexo Themes 官方页面 或者 GitHub 搜索自己喜欢的主题。\n\n安装主题进入博客目录的 themes 文件夹，运行以下命令安装主题：\ngit clone https://github.com/iissnan/hexo-theme-next themes/next\n\n修改配置打开博客根目录下的 _config.yml 文件，找到 theme 参数，将其修改为安装的主题名称，例如：\ntheme: next\n\n阅读主题文档每个主题都会附带详细的文档，建议认真阅读文档了解主题的功能和个性化设置。\n\n\n\n提示：如果不需要特别的个性化定制，只需调整 _config.yml 文件中的基础配置即可，节省时间和精力。\n\n\n6. 关于 Netlify 的使用体验(不推荐使用)Netlify 是一款优秀的静态网站托管工具，可以实现自动化部署和免费的 HTTPS 支持。然而，对于数据量较小的个人博客，手动部署往往更加高效。\n手动部署步骤\n在本地完成 Markdown 文件的编辑后，执行以下命令：\nhexo cleanhexo generatehexo deploy\n\n\nhexo clean：清理旧的生成文件。\nhexo generate：生成新的静态页面。\nhexo deploy：将静态页面上传到 GitHub 仓库。\n\n\n提交静态文件到 GitHub 后，即可通过 GitHub Pages 访问你的博客。\n\n\nNetlify 的优缺点\n优点：\n自动化构建和部署，操作简单。\n免费提供 SSL 证书，支持 HTTPS。\n支持定制化域名配置。\n\n\n缺点：\n国内访问速度较慢。\n对于更新频率较低的小型博客，功能显得多余。\n\n\n\n\n建议：如果你的博客更新频繁且需要简化部署流程，推荐使用 Netlify 的自动化功能；否则手动部署更适合日常使用。\n\n\n7. 阅读官方文档的重要性阅读官方文档 是掌握 Hexo 和其他技术的关键。官方文档通常提供以下内容：\n\n快速入门：如何快速搭建基础框架。\n配置说明：详解配置文件的参数及其用途。\n个性化功能：指导用户如何调整样式、功能和插件。\n\n官方文档阅读建议\n充分利用翻译工具如果官方文档没有中文版本，可以使用 沉浸式翻译插件，支持快捷翻译整个页面。常用快捷键：\nCtrl+A：一键翻译。\n\n\n多动手实践仔细阅读 _config.yml 和主题的配置文件，结合文档进行调整，能够快速熟悉 Hexo 的工作原理。\n\n\n提示：搭建博客的过程不仅是技术上的学习，更是对内容表达和个性化创作的一次探索。\n总结经验：\n使用合适的工具：如 NVM、Git Bash 和翻译插件。\n多读文档：官方文档和主题文档是最可靠的参考资料。\n量力而行：根据实际需求选择功能，避免过度定制。\n\n","tags":["Hexo Github Github"]},{"title":"first log","url":"/2025/01/18/0025f1e86c2e/","content":"我的第一篇博客\n在mikey的强烈要求下我还是选择打了一个博客网站\n不过咱说博客肯定是要自己有外露的网站才霸气侧漏，等如果真的写得比较多了就整一个自己的域名反正也不贵哈哈哈\n","tags":["hexo npm github.io"]},{"title":"网站更新搭建日志","url":"/2025/01/20/d6d47bcc10b2/","content":"1.18 完成网站的基础搭建1.19 根据keep主题使用手册完成网站的美化功能拓展1.基础信息，菜单美化，首屏特效设置美化2.首页文章底部信息展示，文章字数统计、阅读时长、作者标识、版权信息、分享功能TODO: 分享功能有问题\n3.文章整体的目录结构和点击目录跳转对应位置，网站计数，搜索评论TODO: 评论功能受限\n1.20 完成更新内容1.分享功能问题解析：由于某些文章的文章名为中文，在微信识别网站链接时出现乱码以及不能识别的问题，所以导致扫码不能正确的显示文章路径，于是出现404的问题\n问题解决：在拼写文章路径时用哈希值代替文章的标题保证每个文章的路线不重复且不会出现乱码问题\nurl: https://wuhu233.sitepermalink: :year/:month/:day/:hash/\n\n2.文章评论问题问题解析：由于这个网站的服务器是由GitHub提供也就是在海外用valine自带的搜服务并不能正确进行解析与映射，所以不能连接上。\n问题解决：把serve URL给删掉让服务器自动找合适的地址来访问\n","tags":["hexo"]},{"title":"权限握手拦截器与编辑锁机制：深入理解与实践","url":"/2025/03/06/194f6723e95f/","content":"权限握手拦截器与编辑锁机制：深入理解与实践在现代软件系统，尤其是分布式系统和高并发应用中，权限控制与数据一致性是两个至关重要的核心问题。为了保障系统的安全性与稳定性，开发者常常会采用诸如 权限握手拦截器（Permission Handshake Interceptor） 和 编辑锁机制（Edit Lock Mechanism） 这样的技术手段来实现访问控制与资源协调。\n本文将详细介绍这两个机制的原理、应用场景以及实际开发中的实现方式，并结合具体代码示例进行说明。\n\n一、权限握手拦截器（Permission Handshake Interceptor）1. 概念介绍权限握手拦截器是一种在请求到达业务逻辑层之前，用于验证用户身份与权限的中间件或拦截机制。它通常被部署在 Web 框架（如 Spring Boot、Express.js 等）的前置处理流程中，用于统一处理权限校验逻辑。\n其名称“握手”来源于网络通信中的三次握手过程，表示客户端与服务端之间建立连接前的身份确认。在这里，“握手”指的是对用户身份及权限的一次快速验证。\n2. 核心作用\n防止未授权用户访问敏感接口。\n统一权限校验逻辑，减少重复代码。\n支持灵活配置，例如基于角色（RBAC）、属性（ABAC）等策略。\n提升系统安全性，避免越权操作。\n\n3. 实现原理以 Java 的 Spring Boot 框架为例，可以使用 HandlerInterceptor 接口来实现权限拦截器：\n@Componentpublic class PermissionHandshakeInterceptor implements HandlerInterceptor &#123;    @Autowired    private AuthService authService;    @Override    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;        String token = request.getHeader(&quot;Authorization&quot;);        if (token == null || !authService.validateToken(token)) &#123;            response.sendError(HttpServletResponse.SC_UNAUTHORIZED, &quot;Invalid or missing token&quot;);            return false;        &#125;        String userId = authService.getUserIdFromToken(token);        String requestUri = request.getRequestURI();        if (!authService.hasPermission(userId, requestUri)) &#123;            response.sendError(HttpServletResponse.SC_FORBIDDEN, &quot;Access denied&quot;);            return false;        &#125;        return true;    &#125;&#125;\n\n注册拦截器：\n@Configurationpublic class WebConfig implements WebMvcConfigurer &#123;    @Autowired    private PermissionHandshakeInterceptor permissionInterceptor;    @Override    public void addInterceptors(InterceptorRegistry registry) &#123;        registry.addInterceptor(permissionInterceptor)                .addPathPatterns(&quot;/**&quot;)                .excludePathPatterns(&quot;/login&quot;, &quot;/register&quot;);    &#125;&#125;\n\n4. 应用场景\n用户登录后访问受保护的 API。\n后台管理系统中不同角色之间的权限隔离。\n微服务架构中跨服务调用的身份验证。\n\n\n二、编辑锁机制（Edit Lock Mechanism）1. 概念介绍编辑锁机制是一种用于防止多个用户同时修改同一份数据而导致冲突的技术。它常用于内容管理系统（CMS）、在线文档协作平台（如 Google Docs）、电商平台的商品编辑等场景中。\n该机制的核心思想是在用户开始编辑某个资源时，对该资源加锁，其他用户在此期间只能查看而不能编辑，直到锁被释放。\n2. 核心作用\n防止数据覆盖或冲突。\n提升用户体验，明确谁正在编辑某项内容。\n支持自动解锁（超时）和手动解锁。\n可作为乐观锁&#x2F;悲观锁的一种实现形式。\n\n3. 实现方式3.1 数据库字段实现（悲观锁）在数据库表中添加一个 editing_lock 字段，记录当前锁定状态与用户 ID：\nALTER TABLE documents ADD COLUMN editing_lock_user_id VARCHAR(36) NULL;ALTER TABLE documents ADD COLUMN editing_lock_time TIMESTAMP NULL;\n\n在用户开始编辑时更新字段：\npublic boolean acquireEditLock(String documentId, String userId) &#123;    Timestamp now = new Timestamp(System.currentTimeMillis());    Timestamp lockTimeout = new Timestamp(now.getTime() - 5 * 60 * 1000); // 超时时间5分钟    int updated = jdbcTemplate.update(        &quot;UPDATE documents SET editing_lock_user_id = ?, editing_lock_time = ? &quot; +        &quot;WHERE id = ? AND (editing_lock_user_id IS NULL OR editing_lock_time &lt; ?)&quot;,        userId, now, documentId, lockTimeout);    return updated &gt; 0;&#125;\n\n释放锁：\npublic void releaseEditLock(String documentId, String userId) &#123;    jdbcTemplate.update(        &quot;UPDATE documents SET editing_lock_user_id = NULL, editing_lock_time = NULL &quot; +        &quot;WHERE id = ? AND editing_lock_user_id = ?&quot;,        documentId, userId);&#125;\n\n3.2 Redis 实现（分布式环境）在分布式系统中，可借助 Redis 实现更高效的锁管理：\npublic boolean tryAcquireLock(String resourceId, String userId, long expireSeconds) &#123;    Boolean success = redisTemplate.opsForValue().setIfAbsent(        &quot;edit_lock:&quot; + resourceId,        userId,        expireSeconds,        TimeUnit.SECONDS    );    return Boolean.TRUE.equals(success);&#125;public void releaseLock(String resourceId, String userId) &#123;    String currentUserId = redisTemplate.opsForValue().get(&quot;edit_lock:&quot; + resourceId);    if (userId.equals(currentUserId)) &#123;        redisTemplate.delete(&quot;edit_lock:&quot; + resourceId);    &#125;&#125;\n\n4. 应用场景\n在线文档协同编辑（如腾讯文档、石墨文档）。\n多人协作的内容管理系统。\n电商后台商品信息维护，防止多人误操作。\n工单系统中任务分配与编辑。\n\n\n三、两种机制的比较与整合\n\n\n特性\n权限握手拦截器\n编辑锁机制\n\n\n\n目标\n控制访问权限\n控制并发修改\n\n\n层级\n请求入口级别\n数据操作级别\n\n\n技术实现\n拦截器、过滤器、JWT、OAuth\n数据库字段、Redis、ZooKeeper\n\n\n是否强制\n是（拒绝非法访问）\n否（仅提示或阻止）\n\n\n应用范围\n所有接口\n修改类接口\n\n\n在实际项目中，这两种机制往往需要配合使用：\n\n先通过权限握手拦截器判断用户是否有资格访问接口；\n再通过编辑锁机制判断是否允许修改特定资源。\n\n例如，在一个 CMS 系统中，用户 A 正在编辑文章 X，此时用户 B 尝试访问编辑页面：\n\n权限拦截器允许 B 查看但不允许编辑（若无编辑权限）；\n若 B 有权限但发现资源已被锁，则提示“当前资源正由 A 编辑中”。\n\n\n四、总结权限握手拦截器和编辑锁机制是构建安全、稳定、高效系统不可或缺的两大支柱：\n\n权限握手拦截器确保只有合法用户才能访问系统资源；\n编辑锁机制确保在同一时间内只有一个用户能够修改共享资源，从而避免数据冲突。\n\n在实际开发中，我们应根据系统架构、业务需求、并发量等因素选择合适的实现方式。无论是采用数据库字段还是 Redis 分布式锁，关键在于设计出清晰、可维护、易扩展的权限与锁管理模块。\n","tags":["java"]},{"title":"Disruptor 如何处理环形缓冲区溢出问题","url":"/2025/03/08/9cd65bb14d3f/","content":"Disruptor 如何处理环形缓冲区溢出问题当我们谈论高性能并发框架时，Disruptor 无疑是一个耀眼的存在。它利用了 环形缓冲区（Ring Buffer） 来实现高效的线程间通信。然而，在实际应用中，一个常见的问题是：如果生产者生产的事件速度超过了消费者的处理速度，就会发生所谓的“溢出”问题——即新的事件没有足够的空间存储。那么，Disruptor 是如何应对这一挑战的呢？\n\n一、理解环形缓冲区的工作原理首先，我们需要了解 Ring Buffer 的基本工作原理。Ring Buffer 实际上是一块固定大小的循环数组，所有的读写操作都在这个数组上进行。每个位置只能存放一个事件对象，并且一旦指针走到末尾就会自动绕回到起点。\n在 Disruptor 中，有一个重要的概念叫做 Sequence（序号），用于追踪当前生产者和消费者的位置。每当一个新的事件被写入 Ring Buffer 时，生产者的 Sequence 就会向前移动；当某个消费者完成对某个事件的处理后，它的 Sequence 也会相应地更新。\n序号协调器（Sequence Barrier）为了确保数据的一致性和正确性，Disruptor 使用了 Sequence Barrier 来协调不同角色之间的交互。例如，生产者在尝试写入新事件之前，必须先检查所有消费者的 Sequence，以确定是否有足够的空闲槽位可用。\n\n二、解决溢出问题的策略尽管 Ring Buffer 的设计初衷是为了提供一种高效的数据交换方式，但在某些情况下，仍可能出现生产速度超过消费速度的情况。这时，就需要采取措施来避免溢出。以下是 Disruptor 提供的一些解决方案：\n1. 预分配足够的容量最直接的方法就是根据预期的最大负载来设置 Ring Buffer 的大小。这意味着你需要对系统的吞吐量有一定的预估能力。通常情况下，Ring Buffer 的大小应该远大于最大并发请求数，以保证即使在高峰期也能有足够的缓冲空间。\nint bufferSize = 1024; // 根据实际情况调整大小Disruptor&lt;Event&gt; disruptor = new Disruptor&lt;&gt;(factory, bufferSize, executor);\n\n不过，这种方法虽然简单，但并不是万能的。如果你低估了流量，仍然有可能出现溢出。\n2. 等待策略（Wait Strategies）Disruptor 提供了几种不同的等待策略来处理生产者与消费者之间的同步问题。这些策略决定了当生产者发现 Ring Buffer 满了时应该如何行动。\n\nBusySpinWaitStrategy：生产者将不断轮询直到有空位可用。这种方式适合对延迟要求极高的场景，但它会消耗大量的 CPU 资源。\n\nYieldingWaitStrategy：类似于 Busy Spin，但如果一段时间内未获得资源，则会让出 CPU 时间片给其他线程。适用于低延迟但不需要极致性能的场合。\n\nSleepingWaitStrategy：当无法获取资源时，生产者会选择休眠一段时间再重试。这种策略可以降低 CPU 使用率，但会增加一定的延迟。\n\nBlockingWaitStrategy：当 Ring Buffer 满时，生产者会被阻塞直到有空位为止。这是最保守的选择，适合对吞吐量要求不高但希望减少 CPU 占用的场景。\n\n\n选择合适的等待策略可以在一定程度上缓解溢出带来的压力，但它并不能完全解决问题。从根本上讲，还是需要平衡生产和消费的速度。\n3. 控制生产速率为了避免 Ring Buffer 溢出，另一种有效的方法是限制生产者的生成速率。这可以通过引入某种形式的限流机制来实现。例如，当检测到 Ring Buffer 接近满载时，可以暂时停止生产者的工作，直到有足够的空间为止。\n// 假设我们定义了一个阈值，当 Ring Buffer 使用率达到80%时暂停生产if (ringBuffer.getRemainingCapacity() &lt; bufferSize * 0.2) &#123;    Thread.sleep(10); // 简单示例：让生产者暂停一会儿&#125;\n\n当然，这种做法可能会牺牲一部分系统的响应速度，因此需要根据具体的应用场景权衡利弊。\n4. 扩展消费者的能力除了控制生产端之外，另一个方向是从消费端入手，通过增加消费者数量或者优化消费者逻辑来提高整体的处理效率。比如，可以考虑并行化某些耗时的操作，或者采用更高效的数据结构和算法来加速处理过程。\n\n三、总结Disruptor 在设计之初就充分考虑到了高并发环境下的各种挑战，包括 Ring Buffer 溢出的问题。通过合理配置 Ring Buffer 的大小、选择适当的等待策略以及实施有效的流量控制措施，我们可以有效地预防或减轻溢出带来的影响。\n然而，值得注意的是，没有任何一种方案能够适用于所有情况。实际开发过程中，往往需要结合具体的业务需求和技术条件来进行综合考量。只有这样，才能充分发挥 Disruptor 的潜力，构建出既稳定又高效的系统\n","tags":["java"]},{"title":"Disruptor 与其他无锁队列相比的优势","url":"/2025/03/08/f7f452b4a772/","content":"Disruptor 与其他无锁队列相比的优势大家好,今天我想和大家分享一下我在学习高性能并发编程过程中对 Disruptor 的一些理解，尤其是它相较于其他常见的无锁队列（如 Java 中的 ConcurrentLinkedQueue 或 LinkedBlockingQueue）有哪些优势。\n在多线程环境下，如何高效、安全地进行数据传递是一个核心问题。为了实现这一点，很多语言和框架都提供了各种类型的队列结构。而 无锁队列（Lock-Free Queue） 因为其无需使用传统锁机制，在高并发场景下具有更好的性能表现，受到了越来越多开发者的关注。\n\n一、常见无锁队列简介在进入正题之前，我们先简单回顾一下 Java 中几个常见的无锁或低锁竞争的队列：\n\nConcurrentLinkedQueue：一个基于链表结构的无界无锁队列，适用于生产者-消费者模型。\nLinkedBlockingQueue：虽然内部有锁，但通过分离读写锁来降低竞争，性能较好。\nSynchronousQueue：不存储元素的队列，直接传递数据，适合高并发任务调度。\nArrayBlockingQueue：有界阻塞队列，使用 ReentrantLock 控制访问。\n\n这些队列各有优劣，但在某些极端高并发的场景下，它们可能无法满足我们对吞吐量和延迟的极致追求。\n\n二、Disruptor 的设计哲学Disruptor 是由英国金融公司 LMAX 开发的一种高性能事件处理框架，其底层采用了一个叫做 环形缓冲区（Ring Buffer） 的结构。这个结构不同于传统的链表或数组队列，它是固定大小、预分配内存的，并且通过一系列巧妙的设计避免了锁的使用。\nDisruptor 的目标很明确：以最低的延迟、最高的吞吐量完成线程间通信。\n\n三、Disruptor 相比其他无锁队列的核心优势接下来我们重点来看看 Disruptor 在哪些方面做得更好。\n1. 真正的无锁设计Disruptor 使用的是 CAS（Compare and Swap）+ volatile 变量 的方式来实现线程同步，而不是依赖传统的互斥锁或者重入锁。\n相比之下，像 ConcurrentLinkedQueue 虽然是无锁的，但在多线程同时操作时仍需频繁进行 CAS 操作，容易造成“自旋”浪费 CPU 时间。而 Disruptor 通过 Sequence 追踪机制和 Barrier 协调器，使得多个消费者之间能够高效协作，避免不必要的冲突。\n2. 预分配内存 + 环形缓冲区Disruptor 的 Ring Buffer 在初始化时就将所有空间分配完毕，避免了运行时动态扩容带来的 GC 压力。这对于需要长时间运行的系统来说是非常重要的优化手段。\n而像 ConcurrentLinkedQueue 是基于链表实现的，每次添加元素都需要新建节点对象，频繁创建和回收对象会增加 JVM 的垃圾回收压力。\n3. 顺序访问 + 缓存友好Disruptor 的 Ring Buffer 是一块连续的内存区域，CPU 缓存命中率高，访问效率远高于链表结构。\nJava 的 ConcurrentLinkedQueue 由于是链表结构，节点分布在内存的不同位置，容易导致缓存不命中，影响性能。\n4. 支持多消费者并行消费Disruptor 支持多个消费者并行消费同一个事件流，并且可以配置消费者之间的依赖关系（例如 A 处理完后 B 才能处理），这种灵活的拓扑结构非常适合复杂业务场景下的流水线式处理。\n相比之下，普通的队列通常只能做到单一消费者或简单的并行处理，缺乏这种精细的控制能力。\n5. 更高的吞吐量与更低的延迟根据官方测试数据，Disruptor 在单机环境下可以轻松达到每秒百万级的消息处理能力，而平均延迟可以控制在纳秒级别。\n这在金融交易、高频日志处理、实时监控等对性能要求极高的场景中，Disruptor 的优势尤为明显。\n\n四、适用场景对比总结\n\n\n特性\nDisruptor\nConcurrentLinkedQueue\nLinkedBlockingQueue\n\n\n\n是否无锁\n✅ 完全无锁\n✅ 部分无锁\n❌ 有锁\n\n\n内存分配方式\n✅ 预分配\n❌ 动态分配\n❌ 动态分配\n\n\n数据结构\n✅ 环形缓冲区\n✅ 链表\n✅ 数组\n\n\n吞吐量\n⭐⭐⭐⭐⭐\n⭐⭐⭐\n⭐⭐⭐⭐\n\n\n延迟\n⭐⭐⭐⭐⭐\n⭐⭐⭐\n⭐⭐⭐\n\n\n多消费者支持\n✅ 强大支持\n❌ 有限支持\n❌ 较弱\n\n\n适用场景\n高频交易、日志系统\n一般并发任务\n中等并发任务\n\n\n\n五、小结总的来说，Disruptor 并不是为了替代所有的队列结构而存在的，而是针对那些对性能、延迟、吞吐量有极高要求的场景提供了一种更优的解决方案。\n如果你正在开发一个高并发系统，比如实时消息中间件、日志采集平台、金融交易引擎等，那么 Disruptor 是非常值得深入研究和使用的工具。\n当然，它的学习曲线也相对陡峭一些，需要你对并发编程、内存模型、CPU 缓存等基础知识有一定了解。但对于每一个希望写出高性能代码的开发者来说，Disruptor 都是一块不可多得的技术瑰宝\n","tags":["java"]},{"title":"Disruptor 无锁队列：并发世界的“高效沟通大师”","url":"/2025/03/08/0d2323b99b71/","content":"Disruptor 无锁队列：并发世界的“高效沟通大师”💬在高并发的世界里，线程们就像一群忙碌的快递员，他们需要频繁地传递信息、处理任务。而这些信息和任务，通常被放在一个叫做 队列（Queue） 的地方。传统的队列，比如 BlockingQueue，虽然能完成基本的工作，但在面对海量请求时，常常显得力不从心。\n于是，一位名叫 Disruptor 无锁队列 的新成员闪亮登场了。它不是那种靠加锁来维持秩序的老派角色，而是以一种优雅又高效的方式，让多个线程之间实现了“默契配合”的艺术。今天，我们就来认识一下这位并发世界中的“沟通大师”。\n\n🌟 一、Disruptor 是谁？他有什么特别？Disruptor 是由英国金融公司 LMAX 开发的一种高性能事件处理框架，其核心是一个基于 环形缓冲区（Ring Buffer） 的无锁队列结构。它的设计目标是实现 低延迟、高吞吐量 的并发处理能力。\n\n简单来说，Disruptor 就像是一个没有红绿灯却依旧井然有序的十字路口，所有车辆（线程）都能快速通过而不发生碰撞。\n\n🔑 它的关键特点：\n✅ 无锁设计：使用 CAS（Compare and Swap）操作代替传统锁机制，避免线程阻塞。\n✅ 预分配内存：环形缓冲区在初始化时就分配好固定大小的内存空间，避免频繁 GC。\n✅ 顺序访问：数据按顺序写入和读取，提高 CPU 缓存命中率。\n✅ 多消费者支持：可以配置多个消费者线程并行消费消息，提升整体性能。\n\n\n🎯 二、为什么我们需要无锁队列？在并发编程中，最让人头疼的问题之一就是线程之间的竞争。当多个线程同时尝试修改共享资源时，如果不加以控制，就会出现数据混乱、死锁等问题。传统的解决方案是加锁，但加锁意味着排队等待，效率低下。\n而 Disruptor 使用了一种叫 CAS + volatile 变量 的方式来实现线程安全，不需要阻塞线程，也不需要上下文切换，从而大大提高了系统的响应速度和吞吐能力。\n\n如果说传统队列是公交车站——大家排队上车，那 Disruptor 就是高速公路——你追我赶，互不干扰。\n\n\n🧠 三、Disruptor 的工作原理：一场有组织的信息接力赛想象一下，Disruptor 就像是一场精心安排的信息接力赛，每个参与者都有自己的职责和节奏。\n🏁 1. 环形缓冲区（Ring Buffer）Disruptor 的核心结构是一个 固定大小的环形数组，称为 Ring Buffer。这个缓冲区就像是一个跑道，生产者往里面放数据，消费者从里面拿数据。\n\n每个位置只能存放一个事件对象。\n所有位置在初始化时就已经分配好内存，不会动态扩容。\n当指针走到末尾时会自动绕回到起点，形成“环”。\n\n🧍‍♂️ 2. 生产者（Producer）生产者负责向 Ring Buffer 中发布事件。它可以是一个或多个线程，通过 CAS 操作确保每次只有一位生产者能够成功写入某个位置。\n\n生产者就像是传送带上的工人，不断把包裹放进箱子（缓冲区），然后交给下一个人处理。\n\n👨‍💻 3. 消费者（Consumer）消费者则从 Ring Buffer 中取出事件进行处理。Disruptor 支持多个消费者并行消费，也可以设置依赖关系，例如 A 处理完后 B 再处理。\n\n消费者就像是流水线上的工程师，每个人专注于自己的工序，相互协作完成最终的产品。\n\n🚦 4. 序号协调器（Sequence Barrier）Disruptor 使用序号（Sequence）来追踪每个位置的状态。消费者通过 Sequence 来判断当前是否可以读取该位置的数据，而生产者则通过检查消费者的进度来决定是否可以覆盖旧数据。\n\nSequence Barriers 就像是交通信号灯，告诉各个线程：“你可以走了”，“请等一下”。\n\n\n💡 四、举个栗子：用 Disruptor 实现日志处理系统让我们来看一个简单的例子：使用 Disruptor 构建一个高效的日志处理系统。\n🧾 场景描述我们有一个日志生产者不断生成日志事件，两个消费者分别负责将日志写入数据库和发送到监控平台。\n📦 1. 定义事件类public class LogEvent &#123;    private String message;    public void setMessage(String message) &#123;        this.message = message;    &#125;    public String getMessage() &#123;        return message;    &#125;&#125;\n\n🧩 2. 定义事件工厂public class LogEventFactory implements EventFactory&lt;LogEvent&gt; &#123;    @Override    public LogEvent newInstance() &#123;        return new LogEvent();    &#125;&#125;\n\n📣 3. 定义消费者处理器public class DatabaseLoggerHandler implements EventHandler&lt;LogEvent&gt; &#123;    @Override    public void onEvent(LogEvent event, long sequence, boolean endOfBatch) &#123;        System.out.println(&quot;DatabaseLogger: &quot; + event.getMessage());    &#125;&#125;public class MonitorLoggerHandler implements EventHandler&lt;LogEvent&gt; &#123;    @Override    public void onEvent(LogEvent event, long sequence, boolean endOfBatch) &#123;        System.out.println(&quot;MonitorLogger: &quot; + event.getMessage());    &#125;&#125;\n\n🚀 4. 主程序启动 Disruptorpublic class DisruptorDemo &#123;    public static void main(String[] args) throws InterruptedException &#123;        int bufferSize = 1024; // 环形缓冲区大小        Disruptor&lt;LogEvent&gt; disruptor = new Disruptor&lt;&gt;(            new LogEventFactory(),            bufferSize,            DaemonThreadFactory.INSTANCE        );        // 注册两个消费者        disruptor.handleEventsWith(            new DatabaseLoggerHandler(),            new MonitorLoggerHandler()        );        disruptor.start(); // 启动 Disruptor        RingBuffer&lt;LogEvent&gt; ringBuffer = disruptor.getRingBuffer();        // 模拟生产者不断发送日志        for (int i = 0; i &lt; 10; i++) &#123;            long seq = ringBuffer.next(); // 获取下一个可用位置            try &#123;                LogEvent event = ringBuffer.get(seq);                event.setMessage(&quot;Log Message &quot; + i);            &#125; finally &#123;                ringBuffer.publish(seq); // 发布事件            &#125;        &#125;        Thread.sleep(2000);        disruptor.shutdown(); // 关闭 Disruptor    &#125;&#125;\n\n\n🧭 五、适用场景与不适用场景✅ 适用场景\n高频交易系统\n实时日志处理\n游戏服务器的消息队列\n数据采集与分析系统\n\n❌ 不适合的场景\n需要动态扩容的队列\n消息持久化需求强烈\n消息顺序要求不严格（Disruptor 强调顺序性）\n对内存占用非常敏感的嵌入式环境\n\n\n🧵 六、总结：Disruptor —— 并发世界的“沟通艺术家”如果说 Java 原生的并发工具包是一位严谨的工程师，那么 Disruptor 就是一位充满创造力的艺术家。它不仅解决了并发通信的基本问题，更以一种优雅且高效的方式，让线程之间的协作变得流畅自然。\n\n在 Disruptor 的世界里，没有锁的束缚，只有默契的节奏；没有无谓的等待，只有飞快的流转。\n\n如果你正在构建一个对性能、延迟、吞吐量有着极致追求的系统，那么 Disruptor 绝对值得你深入了解和尝试\n","tags":["java"]}]